{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nBlockchain industry\n\n\nThe blockchain industry and the infrastructure of the Internet of Value are being built  rapidly around the globe, and to many the atmosphere is eerily similar to the building of the Internet in the late \u201890s,   with pioneers and dreamers coming together to build a new future. Tomochain can be a leading part of this phenomenon through seamlessly merging an ecosystem of applications with cryptographic tokens used by millions of mainstream users with a unique blockchain infrastructure architecture allowing for a fast, secure, frictionless payment and trusted store of value. Distributed systems have been researched in a \u201dpermissioned setting\u201d where the number of participants in the system and their identities are common knowledge. In 2008, Satoshi Nakamoto - \u201dproposed his celebrated \u201cblockchain protocol\u201d which attempts to achieve consensus in a permissionless setting: anyone can join (or leave) the protocol execution (without getting permission from a centralized or distributed authority), and the protocol instructions do not depend on the identities of the players\u201d. Later on, Ethereum with its Ethereum Virtual Machine (EVM) proposed several significant enhancements compared to Bitcoin, including Smart Contracts. Both Bitcoin and Ethereum have some issues, especially with transaction processing performance. \n\n\nApproach\n\n\nIn order to construct an efficient and secured consensus protocol for Tomochain, we tackle the following main bottlenecks of classic blockchains:\nEfficiency: Existing blockchains as employed by major crypto-currencies(e.g., Bitcoin or Ethereum) do not scale well to handle a large transaction volume, e.g. Bitcoin and Ethereum can handle around 10 transactions/second. This small throughput severely hinders a wide-spread adoption of such crypto- currencies. Confirmation times: The 10 minutes Bitcoin block-time is significantly larger than network latency. Furthermore, a Bitcoin block requires 5 subsequent blocks following it so that it can be confirmed; thus it takes on average one hour for a transaction to be confirmed (with low confidence). While Ethereum uses a smaller block-time, the average confirmation time still remains relatively high, around 13 minutes. These long confirmation times hinder many important applications (especially smart contract applications). Fork Generation: The problem of fork chain consumes computational energy, time, and creates potential vulnerabilities for different types of attacks. With the motivation as mentioned above, our persistent and ultimate goal of research is to propose the consensus protocol focusing on the following key strategies:\nDouble Validation to strengthen security and reduce fork", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/#blockchain-industry", 
            "text": "The blockchain industry and the infrastructure of the Internet of Value are being built  rapidly around the globe, and to many the atmosphere is eerily similar to the building of the Internet in the late \u201890s,   with pioneers and dreamers coming together to build a new future. Tomochain can be a leading part of this phenomenon through seamlessly merging an ecosystem of applications with cryptographic tokens used by millions of mainstream users with a unique blockchain infrastructure architecture allowing for a fast, secure, frictionless payment and trusted store of value. Distributed systems have been researched in a \u201dpermissioned setting\u201d where the number of participants in the system and their identities are common knowledge. In 2008, Satoshi Nakamoto - \u201dproposed his celebrated \u201cblockchain protocol\u201d which attempts to achieve consensus in a permissionless setting: anyone can join (or leave) the protocol execution (without getting permission from a centralized or distributed authority), and the protocol instructions do not depend on the identities of the players\u201d. Later on, Ethereum with its Ethereum Virtual Machine (EVM) proposed several significant enhancements compared to Bitcoin, including Smart Contracts. Both Bitcoin and Ethereum have some issues, especially with transaction processing performance.", 
            "title": "Blockchain industry"
        }, 
        {
            "location": "/#approach", 
            "text": "In order to construct an efficient and secured consensus protocol for Tomochain, we tackle the following main bottlenecks of classic blockchains:\nEfficiency: Existing blockchains as employed by major crypto-currencies(e.g., Bitcoin or Ethereum) do not scale well to handle a large transaction volume, e.g. Bitcoin and Ethereum can handle around 10 transactions/second. This small throughput severely hinders a wide-spread adoption of such crypto- currencies. Confirmation times: The 10 minutes Bitcoin block-time is significantly larger than network latency. Furthermore, a Bitcoin block requires 5 subsequent blocks following it so that it can be confirmed; thus it takes on average one hour for a transaction to be confirmed (with low confidence). While Ethereum uses a smaller block-time, the average confirmation time still remains relatively high, around 13 minutes. These long confirmation times hinder many important applications (especially smart contract applications). Fork Generation: The problem of fork chain consumes computational energy, time, and creates potential vulnerabilities for different types of attacks. With the motivation as mentioned above, our persistent and ultimate goal of research is to propose the consensus protocol focusing on the following key strategies:\nDouble Validation to strengthen security and reduce fork", 
            "title": "Approach"
        }, 
        {
            "location": "/started/", 
            "text": "Getting started\n\n\nBeginners guide\n\n\nGetting TOMO\n\n\nBrowse to https://wallet.tomocoin.io\n\n\nClick on + CREATE NEW WALLET button.\n\n\nUsing the explorer\n\n\nhttps://explorer-testnet.tomochain.com/\n\n\nHow To Vote\n\n\nhttps://validators-testnet.tomochain.com/\n\n\nDapps\n\n\nDeploy dapp tutorial \nhttps://github.com/nuuneoi/tomochain-dapp-example\n\n\nUsing Testnet\n\n\nRunning a Node\n\n\ntodo\n\n\nRunning a Masternode\n\n\ntodo", 
            "title": "Getting started"
        }, 
        {
            "location": "/started/#getting-started", 
            "text": "", 
            "title": "Getting started"
        }, 
        {
            "location": "/started/#beginners-guide", 
            "text": "", 
            "title": "Beginners guide"
        }, 
        {
            "location": "/started/#getting-tomo", 
            "text": "Browse to https://wallet.tomocoin.io  Click on + CREATE NEW WALLET button.", 
            "title": "Getting TOMO"
        }, 
        {
            "location": "/started/#using-the-explorer", 
            "text": "https://explorer-testnet.tomochain.com/", 
            "title": "Using the explorer"
        }, 
        {
            "location": "/started/#how-to-vote", 
            "text": "https://validators-testnet.tomochain.com/", 
            "title": "How To Vote"
        }, 
        {
            "location": "/started/#dapps", 
            "text": "Deploy dapp tutorial \nhttps://github.com/nuuneoi/tomochain-dapp-example", 
            "title": "Dapps"
        }, 
        {
            "location": "/started/#using-testnet", 
            "text": "", 
            "title": "Using Testnet"
        }, 
        {
            "location": "/started/#running-a-node", 
            "text": "todo", 
            "title": "Running a Node"
        }, 
        {
            "location": "/started/#running-a-masternode", 
            "text": "todo", 
            "title": "Running a Masternode"
        }, 
        {
            "location": "/whitepaper/", 
            "text": "The blockchain industry and the infrastructure of the Internet of Value\nare being built rapidly around the globe, and to many the atmosphere is\neerily similar to the building of the Internet in the late \u201890s, with\npioneers and dreamers coming together to build a new future. can be a\nleading part of this phenomenon through seamlessly merging an ecosystem\nof applications with cryptographic tokens used by millions of mainstream\nusers with a unique blockchain infrastructure architecture allowing for\na fast, secure, frictionless payment and trusted store of value.\n\n\nDistributed systems have been researched in a \u201c\npermissioned setting\n\u201d\nwhere the number of participants in the system and their identities are\ncommon knowledge. In 2008, Satoshi Nakamoto - \u201cproposed his celebrated\n\u201cblockchain protocol\u201d which attempts to achieve consensus in a\npermissionless setting: anyone can join (or leave) the protocol\nexecution (without getting permission from a centralized or distributed\nauthority), and the protocol instructions do not depend on the\nidentities of the players\u201d @PassCrypto2017. Later on, Ethereum with its\nEthereum Virtual Machine (EVM) proposed several significant enhancements\ncompared to Bitcoin, including Smart Contracts. Both Bitcoin and\nEthereum have some issues, especially with transaction processing\nperformance. In order to construct an efficient and secured consensus\nprotocol for , we tackle the following main bottlenecks of classic\nblockchains:\n\n\n\n\n\n\nEfficiency:\n Existing blockchains as employed by major\n    crypto-currencies(e.g., Bitcoin or Ethereum) do not scale well to\n    handle a large transaction volume, e.g. Bitcoin and Ethereum can\n    handle around 10 transactions/second. This small throughput severely\n    hinders a wide-spread adoption of such crypto-currencies.\n\n\n\n\n\n\nConfirmation times:\n The 10 minutes Bitcoin block-time\n    \u00a0@Bitcoin08 is significantly larger than network latency.\n    Furthermore, a Bitcoin block requires 5 subsequent blocks following\n    it so that it can be confirmed; thus it takes on average one hour\n    for a transaction to be confirmed (with low confidence). While\n    Ethereum uses a smaller block-time, the average confirmation time\n    still remains relatively high, around 13 minutes\u00a0@Thunder2018\n    [@Cardano2017]. These long confirmation times hinder many important\n    applications (especially smart contract applications).\n\n\n\n\n\n\nFork Generation:\n The problem of fork chain consumes\n    computational energy, time, and creates potential vulnerabilities\n    for different types of attacks.\n\n\n\n\n\n\nWith the motivation as mentioned above, our persistent and ultimate goal\nof research is to propose the consensus protocol focusing on the\nfollowing key strategies:\n\n\n\n\n\n\nDouble Validation to strengthen security and reduce fork\n\n\n\n\n\n\nRandomization to guarantee the fair and prevent handshaking attack\n\n\n\n\n\n\nFast confirmation time and efficient checkpoints for finality or\n    rebase\n\n\n\n\n\n\nTo start dealing with these problems, in this paper, we present an\noverview architectural design of \u2019s master nodes. In particular, we\npropose (PoSV) consensus, a Proof-of-Stake (PoS)-based blockchain\nprotocol with a fair voting mechanism, rigorous security guarantees and\nfast finality. We also present a novel reward mechanism and show that,\nwith this mechanism, the blockchain has a low probability of forks, fast\nconfirmation times, plus the contributions and benefits of masternodes\nare fair in the sense that the probability distribution function is\nuniform eventually.\n\n\nStructure of the remainder of the paper\n.\nSection: \nTomochainOverview\n explains the intuition ideas and\noverview architectural design of masternodes, framework and background\nprotocols that help mass readers (e.g., investors, traders, others) who\nmay not have technical knowledge understand our mechanism easily.\nSection: \nStakeVoting\n presents stakeholder policy, masternode\ncommittee voting systems, and reward mechanism.\nSection\u00a0\nSec:ProtocolOverview\n explains the motivation and double\nvalidation process as well as finality checkpoint of the protocol. In\nSection\u00a0\nSec:ProtocolFormalization\n, we present the formalization of\nour model in a mathematical way to show the soundness of our model and\nprotocol. Section\u00a0\nSec:SecurityAnalysis\n discusses the security\nanalysis and resistant strain of potential attacks. We discuss and\ncompare with several existing blockchains in\nSection\u00a0\nSec:relatedwork\n. Finally, we conclude the paper in Section\n\nSec:Conclusion\n.\n\n\nTomochain Masternode Design\n\n\nThe Tomochain architecture\n\n\nThe blockchain is produced and maintained by a set of \nmasternodes\n in a\nconsistent manner through the protocol as shown in Fig.\n\narchitecture\n. These masternodes are full nodes that hold $TOMO.\nFor a coin-holder to become a masternode, two requirements must be\nsatisfied:\n\n\n\n\n\n\nThe coin-holder must hold at least a minimum required amount of coin\n    (see next section for more details).\n\n\n\n\n\n\nThe coin-holder must be one of the most voted masternode candidates\n    in the system. The voting by coin-holders is credited through a\n    \nVoting DApp\n that allows coin-holders to \nsend $TOMO through the\n    smart contract mechanism\n.\n\n\n\n\n\n\nIn addition to the voting system which is an improvement over the\ncurrent Bitcoin and Ethereum blockchain, also provides a new technique,\nnamely \nDouble Validation\n complemented with a \nRandomization\n\nmechanism. This new technique significantly decreases the probability of\nhaving invalid blocks in the blockchain. These enhancements and the\ncomponents of are step-by-step detailed in the followings.\n\n\n\n\nStakeholders \n Voting\n\n\nCoin Holders, Masternodes\n\n\nCoin-holder is as simple as its name: users who join the network, who\nown and transfer $TOMO. Masternodes are full-nodes which maintain a\ncopy of the blockchain, produce blocks and keep the chain consistent. It\nis worth noting that, does not have miners as in the current\nProof-of-Work-based blockchain systems such as Bitcoin and Ethereum.\nOnly masternodes can produce and validate blocks.\n\n\nMasternodes are selected via a voting system. The first requirement of\nbeing masternodes is to deposit 50 000 $TOMO to the Voting Smart\nContract. Then, these depositors are listed as masternode candidates in\nthe Voting DApp, which allows coin-holders to vote for them by sending\n$TOMO to the smart contract.\n\n\nMasternodes which work hard in the system to create and verify blocks\nwill be incentivized with $TOMO. Furthermore, coin holders who vote for\nthese incentivized masternodes will also receive $TOMO in proportion to\nthe amount of $TOMO they have invested via ballots. engineers take\nresponsibility to design that fair, explicit, automated and accountable\nreward mechanism.\n\n\nThe list of masternode candidates is dynamically sorted based on voted\ncoins. The performance of the masternodes will be tracked and reported\nback to the coin holders in terms of three main metrics: CPU/Memory\ncharts which ensure the workload of the masternodes, the number of\nsigned blocks which indicates their work performance and the last signed\nblock which figures out their last activity. Coin-holders, at any time,\ncan unvote masternodes, who have low performance, and give their votes\nto the other masternodes who have beter performance. Coin-holders have\nincentives to do that because their voted coins are seen as investment\nto their supported masternodes, thus they should choose a voting\nstrategy in order to maximize their profit from the investment.\n\n\nThis simple trick keeps the system healthy since masternodes always have\nto race for their position so that all weak masternodes will eventually\nbe eliminated. Therefore, only the strongest masternodes are voted and\ncan flourish.\n\n\nVoting \n Masternode Committee\n\n\nThere are maximum ninety-nine masternodes elected in the masternode\ncommittee. The required amount of deposit for masternode role is set at\n50 000 $TOMO. This amount is locked in a \nvoting smart contract\n. Once\na masternode is demoted (by not remaining in the top ninety-nine voted\nmasternodes) or intentionally quits the masternode candidates\nlist/masternode committee, the deposit will have been locked for a\nmonth.\n\n\nCoin-holders can vote at any time, by any number of votes (which is\nactually counted by the amount of $TOMO they bet on some masternode\ncandidates). They can use masternode\u2019s performance statistics in the\ngovernance \nVoting DApp\n as reference information to give votes. The set\nof masternodes is dynamically sorted by the amount of $TOMO and counted\nup to ninety-nine, upon reception of votes.\n\n\nReward Mechanism\n\n\nFor each iteration of 990 blocks (called epoch), a checkpoint block is\ncreated, which implements only reward works. The masternode, who takes\nturn in the circular and sequential order to create block, has to scan\nall of the created blocks in the epoch and count number of signatures.\nThe reward mechanism is designed following the policy as follow: the\nhigher number of signatures one masternode has made, the more reward he\nearns. For instance, within an epoch, masternode A who has sealed twice\nthe blocks than masternode B earns double amount of $TOMO than\nmasternode B does.\n\n\nFurthermore, there is also a reward sharing ratio among coin-holders and\nmasternode who has been elected supported by the coin-holders. For\nexample, within an epoch, one masternode receives \nX\n $TOMO. Ten\npercent of \nX\n is sent to the masternode\u2019s address. Eighty percent of\n\nX\n is shared in proportion to the amount of coins deposited and voted\nby the masternode and coin-holders, respectively. The last ten percent\nof \nX\n credits to the foundation. Coin-holders who unvote before the\ncheckpoint block will not receive any shared reward.\n\n\nTomochain Consensus Protocol\n\n\nDouble Validation Process\n\n\nIn , masternodes share equal responsibility to run the system and keep\nit stable. Full nodes should run on powerful hardware configuration and\nhigh-speed network connectivity in order to ensure the required block\ntime (target to two seconds). Only masternodes can produce and seal\nblocks. In order for that, the consensus relies on the concept of\n\nDouble Validation\n that improves some existing consensus mechanisms,\nnamely \nSingle Validation\n. In the followings, we first describe the\n\nDouble Validation\n, then analyze the differences and improvements of\n\nDouble Validation\n compared to \nSingle Validation\n.\n\n\nDouble Validation (DV)\n\n\nSimilar to some existing PoS-based blockchains such as Cardano, each\nblock is created by a block producer, namely masternode, that takes its\nblock creation permission turn following a pre-determined and circular\nsequence of masternodes for each epoch. However, differently from these\nexisting blockchains, DV in requires the signatures of two masternodes\non a block to be able to push the block to the blockchain. One of the\nmasternodes is the \nblock creator\n while the other one, namely \nblock\nverifier\n is randomly selected among the set of voted masternodes that\nvalidates the block and signs it. In the followings, for more\nconvenience, \nblock creator\n and \nblock verifier\n are used\ninterchangeably for the masternode 1 (block producer) and the randomly\nselected masternode 2 for a block, respectively. The process of randomly\nselecting the block verifiers is detailed in the next paragraphs. Note\nthat, there is no mining in the block creation as in Proof-of-Work-based\nblockchains (e.g. Ethereum and Bitcoin). It means that a created block\nis valid if and only if it is sealed by enough two signatures from a\nblock creator and a corresponding block verifier to confirm the\ncorrectness of it.\n\n\nWe believe this DV technique enhances the stability of the blockchain by\ndiminishing the probability of producing \u201cgarbage\u201d blocks while still\nmaintaining the system security and consistency. Randomization of block\nverifiers in DV is the key factor of reducing risks coming from paired\nmasternodes trying to commit malicious blocks. Furthermore, comparing to\nsome current public blockchains in the market, by utilizing the DV\ntechnique, brings significant improvements in the block time by only\nrequiring two signatures per block. For the purpose of showing our\nenhancement over existing PoS-based blockchains, we analyze the\ndifferences between DV and the Single Validation mechanism in some\nexisting blockchains as follows.\n\n\nImprovements of Double Validation over Single Validation\n\n\nLet\u2019s show the improvements of DV compared to Single Validation through\nanalyzing some attacking scenarios as shown in Fig.\n\nfig:singlevalidation\n and Fig. \nfig:doublevalidation\n.\n\n\n\n\nSingle Validation\n In Single Validation, in an epoch, each\n    masternode, e.g. M1, sequentially takes its turn to create a\n    block, e.g. block100. The next masternode, e.g. M2, in the sequence\n    then validates the created block100. If block100 is invalid (that\n    potentially means that M1 is an attacker) and contains a transaction\n    that invalidly benefits M1, if M2 is honest (see Fig.\n    \nfig:singlevalidation\n\n\na\n), it rejects block100 and creates\n    another block100 next to block99. But, if M2 is an attacker\n    (see Fig. \nfig:singlevalidation\n\n\nb\n) that corporates with M1,\n    M2 ignores the invalidation of block100, signs it and creates next\n    block, namely block101 that is valid. Then, the next masternode M3\n    verifies that block101 is valid, M3 signs block101 and creates a\n    block102. By this way, Single Validation potentially leaves the\n    blockchain with \u201cgarbage\u201d or invalid blocks which require a \u201crebase\u201d\n    to restore the validity of the blockchain.\n\n\n\n\n\n\n\n\nDouble Validation\n We claim that our DV technique significantly\n    reduces the probability of having garbage blocks in the blockchain.\n    Assuming that M1 and M2 are the block creator and block verifier,\n    respectively, for block100 in our DV. If block100 is invalid and M2\n    is honest (see Fig. \nfig:doublevalidation\n\n\na\n), M2 will not\n    seal this block. Therefore, the next block creator M3 for creating\n    block101 will see that block100 does not have enough 2 signatures,\n    thus reject block100 and create another block100 next to block99. On\n    the other hand, if M2 is also an attacker pairing/handshaking with\n    M1 (see Fig. \nfig:doublevalidation\n\n\nb\n), M2 signs block100\n    despite its invalidity (remember that the block verifier M2 is\n    randomly selected, there has little chance of successfully pairing\n    M1 and M2). Next, even though M3 will verify that block100 has two\n    valid signatures, M3 still rejects it because block100 is\n    invalidated by M3 that will create another valid block100. In order\n    to break the stability and consistency of the blockchain in this\n    case, M3 should be an attacker together with M1 and M2, which,\n    however, has a very low probability. In other words, DV strengthens\n    the consistency of the blockchain and makes it hard to break.\n\n\n\n\n\n\nRandomization for Block Verifiers for Double Validation\n\n\nThe First Masternode/Block Creator\n\n\nThe first masternode/block creator in a given epoch \ne\n can be selected\nby a round-turn game and can be formal defined as an array:\n\n\n\n\n\\begin{bmatrix} \n\\nu_1\n\\end{bmatrix}\n= \\begin{bmatrix} \nV_{1.1}^e  \\\\\nV_{1.2}^e\\\\\n\\cdot\\\\\n\\cdot\\\\\n\\cdot\\\\\nV_{1.n-1}^e\\\\\nV_{1.n}^e\\\\\n\\end{bmatrix}\n\n\n\n\nRandom Matrix and Smart Contract\n\n\nLet \nm\n be the number of masternodes, \nn\n be the number of slots in an\nepoch. In order to randomly generate the block verifiers for the next\nepoch \ne+1\n, the process is performed by the following steps.\n\n\n\n\n\n\nStep 1: Random Numbers Generation and Commitment Phase:\n\n\nFirst, at the beginning of epoch \ne\n, each masternode \nV_i\n will\nsecurely create an array of \nn+1\n special random numbers\n\n Recommend_i= [ r_{i.1}, r_{i.2}, ..., r_{i.n}, \\theta_i]\n, where\n\nr_{i.k}\\in [1, ..., m]\n indicating the recommendation of ordered\nlist of block verifiers for the next epoch of \nV_i\n, and\n\n\\theta_i \\in \\{-1, 0, 1\\}\n is used for increasing the\nunpredictability of the random numbers. Second, each masternode\n\nV_i\n has to encrypt the array \nRecommend_i\n using a secret key, say\n\nSecret_i = Encrypt (Recommend_i)\n. Next, each masternode forms a\n\"\nlock\n\u201d message that contains encrypted shares \nSecret_i\n; signs\nthis message with its blockchain\u2019s private key, specifies the\nepoch\u2019s number and attaches its public key. In this case, every\nmasternode can check who created this \nlock\n message and which epoch\nit relates to. Then, each node \nV_i\n sends this \nlock\n message to a\n\nSmart contract\n stored in a block of the blockchain, so\neventually each masternode collects and knows the \nlock\ns from all\nother masternodes.\n\n\n\n\n\n\nStep 2: Discovery and Recovery Phase:\n The discovery phase is\n    where a masternode sends an \u201d\nunlock\n\u201d message, or special value for\n    other masternodes to open its \nlock\n. A \nlock\n is like a black box\n    (with a secret value \nSecret_i\n encrypted of \nRecommend_i\n in it),\n    and the act of opening involves a key that reveals the box to\n    retrieve the value of \nRecommend_i\n. Eventually, a masternode has\n    both \nlock\ns and \nunlock\ns of others. If some elector is an\n    adversary and can publish its \nlock\n but not publish its \nunlock\n,\n    in this case, other masternodes can ignore the adversary\u2019s \nlock\n\n    and set all its random values be \n1\n as default. The idea is simple:\n    a masternode can keep working successfully even if some masternodes\n    are adversaries.\n\n\n\n\n\n\nStep 3: Assembled Matrix and Computation Phase:\n At the point of\n    the slot \nn^{th}\n of the epoch \ne\n, the secret arrays \nSecret_I\n in\n    the smart contract will be decrypted by each masternode and return\n    the plain version of \nRecommend_i\n. Each tuple of the first \nn\n\n    numbers of each \nV_i\n will be assembled as the \ni^{th}\n column of an\n    \nn \\times m\n matrix. All the last number \n\\theta_i\n forms a\n    \nm\\times 1\n matrix. Then each nodes will compute the block verifiers\n    ordered list by some mathematical operations as explained below. The\n    resulting output is a matrix \nn \\times 1\n indicating the order of\n    block verifiers for the next epoch \ne+1\n.\n\n\n\n\n\n\nThe Second Masternode/Block Verifier\n\n\nThen, each node soon compute the common array \n\\nu_2\n for the order of\nthe block verifiers by the following steps as in Equation \neq:matrix\n.\n\n\n\n\n\\label{eq:matrix}\n\\begin{bmatrix} \\nu'_2\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nv_{2.1}^{e+1} \\\\\nv_{2.2}^{e+1} \\\\\n\\vdots \\\\\nv_{2.n}^{e+1}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nr_{1.1}  & r_{2.1}            & \\cdots  & r_{m.1}  \\\\\nr_{1.2}     & r_{2.2}       & \\ddots  & \\vdots   \\\\\nr_{1.3}      &  \\ddots   & \\ddots  & r_{m.3}  \\\\\n\\vdots  &              & r_{m-1.n-1}  & r_{m.n-1}  \\\\\nr_{1.n}      & \\cdots      & r_{m-1.n}      & r_{m.n}\n\\end{bmatrix}   \n\\begin{bmatrix}\n\\theta_1  \\\\\n\\theta_2  \\\\\n\\theta_3 \\\\\n\\vdots  \\\\\n\\theta_m\n\\end{bmatrix}\n\n\n\n\n\n\n\\label{eq:eq2}\n\\begin{bmatrix} \\nu_2\n\\end{bmatrix}\n=\n\\begin{bmatrix} \\nu'_2 & mod & m\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\left| v_{2.1}^{e+1}\\right| & mod & m \\\\\n\\left| v_{2.2}^{e+1} \\right| & mod &  m\\\\\n\\vdots \\\\\n\\left| v_{2.n}^{e+1} \\right| & mod & m\n\\end{bmatrix}\n\n\n\n\nThen, \n\\nu_2\n is obtained by modulo operation of element values of\n\n\\nu'_2\n as in Equation \neq:eq2\n:\n\n\nFinality Analysis\n\n\nThere is a standard definition of \u201ctotal economic finality\u201d: it takes\nplace when \n\\frac{3}{4}\n of all masternodes make maximum-odds bets that\na given block or state will be finalized. This condition offers very\nstrong incentives for masternodes to never try colluding revert the\nblock: once masternodes make such maximum-odds bets, in any blockchain\nwhere that block or state is not present, the masternodes lose their\nentire deposit.\n\n\nkeeps that standardization in the design so that one block is considered\nas irreversible if it collects up to \n\\frac{3}{4}\n signatures of all\nmasternodes committee. The time-line of blockchain creation process,\nchecking finality and mark the block as immutable is described as in\nFigure: \nChainMaking\n below.\n\n\n\n\nConsensus Protocol: Formalization\n\n\nBasic Concepts \n Protocol Description\n\n\nWe begin by describing the blockchain protocol in the \"stakeholder and\nvoting\u201d setting, where leaders are assigned to blockchain slots with\nprobability proportional to their (fixed) initial stake and votes\nreceived from coin-holders which will be the effective stake\ndistribution throughout the execution. To simplify our presentation, we\nabstract this leader (chairman and vice-chairman) selection process,\ntreating it simply as an \u201cideal functionality\u201d that faithfully carries\nout the process of randomly assigning masternodes to slots. In the\nfollowing, we explain how to instantiate this functionality with a\nspecific secure computation.\n\n\nTo start, as we are dealing with proof of stake consensus algorithm, we\nfollow the way of formalization in the recent works in the literature\nlike \u00a0@Cardano2017 and \u00a0@Pass2017 [@PassCrypto2017]. In particular, we\nrecall the following concepts and definitions that were presented\nin\u00a0@Cardano2017:\n\n\nTime, Slots, Epoch\n\n\nWe consider a setting where time is divided into discrete units called\n\nslots\n. A ledger, described in more detail below, associates with each\ntime slot (at most) one ledger \nblock\n. Players are equipped with\n(roughly synchronized) clocks that indicate the current slot. This will\npermit them to carry out a distributed protocol intending to\ncollectively assign a block to this current slot. In general, each slot\n\nsl_r\n is indexed by an integer \nr \\in \\{1, 2, . . .\\}\n, and we assume\nthat the real time window that corresponds to each slot has the\nfollowing properties.\n\n\n\n\n\n\nThe current slot is determined by a publicly-known and monotonically\n    increasing function of current time.\n\n\n\n\n\n\nEach player has access to the current time. Any discrepancies\n    between parties\u2019 local time are insignificant in comparison with the\n    length of time represented by a slot.\n\n\n\n\n\n\nThe length of the time window that corresponds to a slot is\n    sufficient to guarantee that any message transmitted by an honest\n    party at the beginning of the time window will be received by any\n    other honest party by the end of that time window (even accounting\n    for small inconsistencies in parties\u2019 local clocks). In particular,\n    while network delays may occur, they never exceed the slot\n    time window.\n\n\n\n\n\n\nIn each slot \nsl_r\n, and for each active masternode \nV_j\n there will be\na set \nS_j(r)\n of public-keys and stake pairs of the form\n\n(vk_i,s_i) \\in {0,1}^* \\times N\n, for \ni = 1,...,n_r\n where \nn_r\n is\nthe number of users introduced up to that slot that will represent who\nare the active participants in the view of \nV_j\n. Public-keys will be\nmarked as \u201cidle\u201d if the corresponding stakeholder has been corrupted.\n\n\nAs mentioned in Section\u00a0\nSec:TomochainOverview\n, in our setting, we\nassume that the fixed collection of \nm\n masternodes\n\nV_1, V_2, ...., V_m\n interact throughout the protocol. Masternode \nV_i\n\npossesses \ns_i\n stake (coin) before the protocol starts. For each \nV_i\n\na verification and signing key pair \n(vk_i,sk_i)\n for a prescribed\nsignature scheme is generated; we assume without loss of generality that\nthe verification keys \nvk_1, . . .\n are known by all stakeholders.\nBefore describing the protocol, we establish basic definitions following\nthe notation of\u00a0@Garay2015.\n\n\n\n\nGenesis Block\n The genesis block \nB_0\n contains the list of\nstakeholders identified by their public-keys, their respective stakes\n\n(vk_1, s_1), . . . , (vk_n, s_n)\n and auxiliary information \n\\rho\n,\nwhere the auxiliary information \n\\rho\n will be used to seed the slot\nleader election process.\n\n\n\n\nState\n A state is an encoded string \nst \\in \\{0,1\\}^\\lambda\n.\n\n\n\n\nBlock\n A block \nB\n generated at a slot \n sl_i \\in \\{sl_1,...,sl_R\\}\n\ncontains the current state \nst \\in \\{0, 1\\}^{\\lambda}\n, data\n\nd \\in \\{0, 1\\}^{*}\n, the slot number \nsl_i\n and a signature\n\n\\Sigma  =  Sign_{ski} (st, d, sl_i)\n computed under \nsk_i\n\ncorresponding to the masternode \nV_i\n generating the block.\n\n\n\n\nBlockchain\n A blockchain \nC\n (or simply chain) relative to the\ngenesis block \nB_0\n is a sequence of blocks \nB_1,..., B_n\n associated\nwith a strictly increasing sequence of slots for which the state \nst_i\n\nof \nB_i\n is equal to \n H (B_{i-1})\n, where \nH\n is a prescribed\ncollision-resistant hash function. The length of a chain \nlen(C) = n\n is\nits number of blocks. The block \nB_n\n is the head of the chain, denoted\n\nhead(C)\n. We treat the empty string \n\\epsilon\n as a legal chain and by\nconvention set \nhead(\\epsilon) = \\epsilon\n.\n\n\n\n\nEpoch\n An epoch is a set of \nR\n adjacent slots\n\nS = \\{sl_1, . . . , sl_R\\}\n. The value \nR\n is also a parameter (slots\nnumber in each epoch) of the protocol we analyze in our model.\n\n\nAs mentioned earlier, in our model, we set each time \nslot\n \nsl_i\n as 2\nseconds; an epoch is a set \nR\n of 990 slots\n\n\\{ sl_1, sl_2, ..., sl_{990}\\}\n (an epoch time duration equals to 1980\nseconds).\n\n\nIn summary, the consensus protocol of can be formalized in\nAlgorithm\u00a0\nAl:ValidatorGeneration\n. The\nAlgorithm\u00a0\nAl:ValidatorGeneration\n is simulated and explained as a\nprocess shown in Fig. \nEpochProcess\n.\n\n\n\n\nSecurity Analysis\n\n\nNothing-at-stake\n\n\nNothing-at-stake is a well-known problem in PoS-based blockchain, just\nlike 51% attack in PoW algorithm. PoW-based miners require CapEx\n(capital expenditures) for buying mining equipment such as ASICs and\nOpEx (operation expenditures) such as electricity to solve mathematical\npuzzles securing the network @capex. That means, there is always an\nintrinsic cost for miners in mining regardless of its success. In case\nof a fork, miners therefore always allocate their resource (equipment)\nto the chain that they believe is correct in order to get incentives for\ncompensating the intrinsic costs in mining.\n\n\nIn the contrary, in PoS-based systems without mining, during an ideal\nexecution, for creating a fork only costs, masternodes actually do not\nincur intrinsic costs, other than roughly some block validation and\nsigning cost. As a result, there\u2019s an inherent problem of the masternode\nhaving no downside to staking both forks. Therefore, there are actually\ntwo issues in the original design of PoS. On one hand, for any\nmasternode, the optimal strategy is to validate every chain/fork, so\nthat the masternode gets their rewards no matter which fork wins. On the\nother hand, for attackers/malicious masternodes, they can easily create\na fork for double spending.\n\n\nLet\u2019s look back how handles these two problems. As a reminder, maintains\na certain order of masternodes in creating and sealing blocks, in each\nepoch. For the first issue, random/arbitrary forks are hardly happened\nbecause the order of block creation masternodes is pre-determined for\neach epoch. Furthermore, the Double Validation mechanism eliminates the\nsecond issue because even one malicious masternode creates two blocks at\nhis turn, only one block then can be validated by the second randomly\nselected masternode.\n\n\nLong-range attack\n\n\nIn , block is valid only if it collects double validation and finalized\nonce \n\\frac{3}{4}\n of masternodes verify. Therefore, as long as the\nnumber of attackers or malicious nodes and/or fail-stop nodes is less\nequal than \n\\frac{1}{4}\n the number of masternodes, the number of\nmasternodes signing a block is at least \n\\frac{3}{4}\n the total number\nof masternodes, which makes the block finalized. Thus, there is no\nchance for one malicious masternode to create longer valid chain because\nother masternodes will refuse it.\n\n\nCensorship Attack\n\n\nIf there are more than \n\\frac{3}{4}\n malicious masternodes in ,\ncensorship attack might happen. For example, these masternodes refuse\nvalid blocks or simply become inactive. In this case, chain is stuck.\n\n\nIn fact, masternodes are paid for their effort of correctly working so\nthat the chain is actively updated in a consistent manner. More\nimportantly, becoming masternode means a certain amount of coins is\nlocked, 50 000 $TOMO in particular. As a result, in order to control\nmore than\n\\frac{3}{4}\n masternodes, attackers must hold a considerable\namount of $TOMO and gain huge support from coin-holders. And because of\nthis, the attackers do not have incentives to do any malicious action to\nharm the chain.\n\n\nHowever, in worst case, has to do a soft fork in order to reduce number\nof masternodes to keep the chain running and figure out slasher\nmechanisms for those malicious masternodes.\n\n\nRelay Attack\n\n\nsupports EIP155\\\n\n(https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md)\n.\nTransactions in are included \nCHAIN\\_ID\n specified for different public\nchains. Table \ntable:chainid\n shows recognized \nCHAIN\\_ID\ns.\n\n\n\n\n\n\n\n\nCHAIN_ID\n\n\nChain(s)\n\n\n\n\n\n\n\n\n\n\n1\n\n\nEthereum mainnet\n\n\n\n\n\n\n2\n\n\nMorden (disused), Expanse mainnet\n\n\n\n\n\n\n3\n\n\nRopsten\n\n\n\n\n\n\n4\n\n\nRinkeby\n\n\n\n\n\n\n30\n\n\nRootstock mainnet\n\n\n\n\n\n\n31\n\n\nRockstock testnet\n\n\n\n\n\n\n42\n\n\nKovan\n\n\n\n\n\n\n61\n\n\nEthereum Classic mainnet\n\n\n\n\n\n\n62\n\n\nEthereum Classic testnet\n\n\n\n\n\n\n1337\n\n\nGeth private chains (default)\n\n\n\n\n\n\n77\n\n\nSokol, the public POA Network testnet\n\n\n\n\n\n\n99\n\n\nCore, the public POA Network main network\n\n\n\n\n\n\n88\n\n\nMainnet\n\n\n\n\n\n\n89\n\n\nTestnet\n\n\n\n\n\n\n\n\n\n\nChains and chain_id\n\n\n\n\nSafety and liveness\n\n\nSafety implies having a single agreed upon chain where there are not two\nor more competing chains with valid transactions in either @Safety. A\nconsensus protocol can be \nsafe\n when blocks have settlement finality,\nor else probabilistic finality. This last sentence reveals that can\nprovide safety because it has a settlement finality.\n\n\nA consensus protocol is considered \nlive\n if it can eventually propagate\nand make valid transactions onto the blockchain @Safety. An occurrence\nof a liveness fault is when transaction omission, information\nwithholding, or message reordering, among a number of violations are\nobserved. This type of fault is unlikely to happen in because the block\ncreation masternodes list is ordered in a pre-determined way for each\nepoch, thus if even an attacking masternode omits some transactions, the\nlatter will be processed and validated by the next honest masternode in\nthe next block.\n\n\nDDOS Attack\n\n\nMasternodes are encouraged to run in well-known public cloud providers\nsuch as AWS, Google Cloud or Microsoft Azure which provides multiple\nDDOS prevention mechanisms. Even in case that some nodes are attacked or\nfail-stop, the network still works correctly as long as the number of\nfailing and/or attacked nodes is less than 1/4 of the number of\nmasternodes.\n\n\nSpam Attack\n\n\nkeeps the same transaction fee mechanism as Ethereum which is indicated\nvia gasPrice. However, supports minimum transaction fee (at 1 wei),\nwhich somehow enables spamming that attacker tries to broadcast a huge\namount of low fee transactions to the system. However, masternodes\nalways sort transactions and pick up only high fee transactions into the\nproposing block. Thus, spammers have little chance to harm the system.\n\n\nRelated work\n\n\nConsensus plays an important role to guarantee the success of\ndistributed and decentralized systems. Bitcoin\u2019s core consensus\nprotocol, often referred to as Nakamoto consensus\u00a0@Bitcoin08, realizes a\n\u201creplicated state machine\u201d abstraction, where nodes in a permissionless\nnetwork reach agreement about a set of transactions committed as well as\ntheir ordering \u00a0@hybrid. However, known permissionless consensus\nprotocols such as Bitcoin\u2019s Nakamoto consensus come at a cost. Bitcoin\nand Ethereum rely on PoW to roughly enforce the idea of \u201cone vote per\nhashpower\u201d and to defend against Sybil attacks. Unfortunately, PoW-based\nBitcoin and Ethereum are known to have terrible performance (Bitcoin\u2019s\ntransaction processing performance is at peak of around 7 transactions\nper second as previously mentioned). Moreover, PoW is much criticized\nbecause it costs a lot of electricity energy.\n\n\nIn order to design an efficient and cost-effective consensus protocol in\nthe permissionless model, PoS has been discussed extensively in the\nBitcoin and Ethereum forum\u00a0@Ethe2014 [@Larime2016]. A PoS blockchain can\nsubstitute the costly PoW in Nakamoto\u2019s blockchain while still providing\nsimilar guarantees in terms of transaction processing in the presence of\na dishonest minority of users, where this \u201cminority\u201d is to be understood\nhere in the context of stake rather than computational\npower\u00a0@Cardano2017. The Ethereum design Casper\u00a0@Casper, published by\nButerin \n Griffith, provides as its initial version a PoW/PoS hybrid\nconsensus protocol, which might eventually switch to a pure PoS system.\nAs in , Ethereum Casper requires that \nvalidators\n (term similar to\nblock creators) have to deposit an amount. In fact, some concepts used\nin such as checkpoint blocks are borrowed from Casper. Our (PoSV)\nconsensus protocol proposed in this paper can be seen as a hybrid model.\nIn particular, first, we apply with voting and \nDouble Validation\n to\ncreate, verify and vote for blocks smoothly and efficiently. Whenever\npotentials of fork branches are detected, we employ the idea in PoW to\nselect the longest branch with the most votes and discard the other\nbranches. With this hybrid approach, does not only increase the\nperformance and security of blockchain, but also reduce the fork\nsituation in an efficient and practical manner.\n\n\nRecently, there are several consensus protocol research works that are\nclosely related to such as EOS\u00a0@EOS and Ouroboros of\nCardano\u00a0@Cardano2017. The mechanism of \nvoting\n for masternodes for\nreaching consensus is utilized by Bitshares @bitshare and EOS @EOS,\nwhose consensus protocol is termed \nDelegated Proof-of-Stake\n (DPoS).\nDPoS is similar to the Proof-of-Stake Voting consensus of in the sense\nthat masternodes (block creators or \nwitnesses\n in DPoS) are elected\nthrough a voting system. However, requires that masternodes need to\ndeposit a required minimum amount of $TOMO to become a masternode\ncandidate, which puts more pressure on the masternodes to work honestly.\nFurthermore, the \nDouble Validation\n mechanism of lowers the\nprobability of handshaking attacks and having invalid blocks, as\npreviously analyzed. EOS also has a maximum of 21 block producers for\neach epoch, which is \nless decentralized\n than with a maximum of 99\nmasternodes elected.\n\n\nThe research-backed Cardano\u00a0@Cardano2017 blockchain solution, namely\nOuroboros, with the ADA coin, which is purely based on Proof-of-Stake,\npromisingly claims to provide rigorous security guarantees. Similarly to\n, Ouroboros has a set of block producers for each epoch for creating\nblocks and each block producer candidate needs to deposit a minimum\namount of stake (an amount of ADA). However, note that, Ouroboros only\nprovides \nSingle Validation\n, while \nDouble Validation\n of provides\nseveral advantages over Single Validation, as previously analyzed. In\nOuroboros, the order of block producers, selected among stakers, is\nbased on a biased randomization while the \u2019s randomization for block\nverifiers is potentially uniform and based on smart contracts.\nFurthermore, the use of voting as in and DPoS enables a more incentive\nequality between stakers: In Ouroboros, stakers with very little stake\nhave a very small probability of becoming block creators, while, in ,\nthese stakers can choose an optimal strategy to vote for potential\nmasternodes to get incentives.\n\n\nConclusion and perspectives\n\n\nIn this paper, we proposed PoSV, a PoS Voting-based blockchain protocol\nwith heuristic and fair voting mechanism, rigorous security guarantees,\nand fast finality. We also presented a novel reward mechanism and show\nthat, with this mechanism, the blockchain has a low probability of\nhaving forks, fast confirmation time, plus the contributions and\nbenefits of masternodes are fair in the sense that the probability\ndistribution function is uniform eventually.\n\n\n0.3cm\n\n\nPerspectives\n\n\n\n\n\n\nFuture work\n The team is currently working on the implementation\n    of the Proof-of-Stake Voting, which will be released on schedule as\n    stated in our roadmap. Furthermore, in parallel with our novel\n    consensus protocol, we will investigate the Sharding mechanism in\n    order to provide even better transaction processing performance. We\n    believe that, the Sharding technique with the stable number of\n    masternodes will provide better stability and efficiency to\n    the blockchain. At the same time, we commit to keep EVM-compatible\n    smart contracts within our masternode sharding framework.\n\n\n\n\n\n\nEconomic sustainability\n is also an important concept for a\n    blockchain based decentralized network. That means to maintain the\n    network in a sustainable condition, an equilibrium needs to be\n    achieved, in which the cost of running the network infrastructure\n    could be offset by the revenues generated. In this context, the cost\n    of network infrastructure consists of two parts: the physical cost\n    of having hardware such as servers, memories that passes the network\n    technical requirements; and the capital cost of having $TOMO locked\n    into smart-contracts. The revenues for Masternodes would primarily\n    come from Reward Engine emission, and later on from service revenues\n    such as token exchange fees provided by applications running on top\n    of TomoChain. We will publish a TomoChain economic analysis and\n    proposal, separate from this technical paper in a later date.\n\n\n\n\n\n\n References\n\n\nSatoshi Nakamoto. Bitcoin: A peer-to-peer electronics cash system. 2008.\n\n\nEthereum Foundation. Ethereum\u2019s White Paper. , 2014. Online available 25/05/2018.\n\n\nD. Larimer. Delegated Proof-of-Stake (DPOS). BitShare White Paper 2014.\n\n\nS. King and S. Nadal. PPCoin: Peer-to-peer crypto-currency with\nproof-of-stake. Self-Published, 2012.\n\n\nV. Buterin. On public and private blockchains. Ethereum Blog, 2015.\n\n\nA. Kiayias, A. Russell, B. David, and R. Oliynykov: Ouroboros: A\nProvably Secure Proof-of-Stake Blockchain Protocol. IACR-CRYPTO-2017.\n\n\nD. Mingxiao, et al. A Review on Consensus Algorithms of Blockchain. 2017\nIEEE International Conference on Systems, Man, and Cybernetics (SMC)\nBanff Center, Banff, Canada, October 5-8, 2017\n\n\nR. Pass and E. Shi. Rethinking Large-Scale Consensus. In the Proceedings\nof the IEEE 30th Computer Security Foundations Symposium, 2017. Thunder\nToken Foundation: Thunder Consensus White Paper, Janurary, 2018.\n\n\nR. Pass, L. Seeman, and A. Shelat. Analysis of the Blockchain Protocol\nin Asynchronous Networks. In EUROCRYPTO 2017.\n\n\nJuan A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone\nprotocol: Analysis and applications. In Elisabeth Oswald and Marc\nFischlin, editors, Advances in Cryptology - EUROCRYPT 2015, Volume 9057\nof Lecture Notes in Computer Science, pages 281\u2013310. Springer, 2015.\n\n\nTendermint Team. Understanding the Basics of a Proof-of-Stake Security\nModel.\nhttps://blog.cosmos.network/understanding-the-basics-of-a-proof-of-stake-security-model-de3b3e160710.\nOnline available 25/05/2018.\n\n\nEOS Team. EOS.IO Technical White Paper v2.\n\nhttps://github.com/EOSIO/Documentation/blob/master/TechnicalWhitePaper.md\n.\nOnline available 25/05/2018.\n\n\nBitshares Team. Delegated Proof-of-Stake Consensus.\nhttps://bitshares.org/technology/delegated-proof-of-stake-consensus/.\nOnline available 25/05/2018.\n\n\nR. Pass, and E. Shi. (2017). Hybrid consensus: Efficient consensus in\nthe permissionless model. In LIPIcs-Leibniz International Proceedings in\nInformatics (Vol. 91). Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik.\n\n\nV. Buterin, and V. Griffith. (2017). Casper the Friendly Finality\nGadget. arXiv preprint arXiv:1710.09437.\n\n\nH. McCook. Under the Microscope: Economic and Environmental Costs of\nBitcoin Mining.\n\nhttps://www.coindesk.com/microscope-economic-environmental-costs-bitcoin-mining/\n.\nOnline available 25/05/2018.", 
            "title": "Technical Whitepaper"
        }, 
        {
            "location": "/whitepaper/#tomochain-masternode-design", 
            "text": "", 
            "title": "Tomochain Masternode Design"
        }, 
        {
            "location": "/whitepaper/#Sec:TomochainOverview", 
            "text": "The blockchain is produced and maintained by a set of  masternodes  in a\nconsistent manner through the protocol as shown in Fig. architecture . These masternodes are full nodes that hold $TOMO.\nFor a coin-holder to become a masternode, two requirements must be\nsatisfied:    The coin-holder must hold at least a minimum required amount of coin\n    (see next section for more details).    The coin-holder must be one of the most voted masternode candidates\n    in the system. The voting by coin-holders is credited through a\n     Voting DApp  that allows coin-holders to  send $TOMO through the\n    smart contract mechanism .    In addition to the voting system which is an improvement over the\ncurrent Bitcoin and Ethereum blockchain, also provides a new technique,\nnamely  Double Validation  complemented with a  Randomization \nmechanism. This new technique significantly decreases the probability of\nhaving invalid blocks in the blockchain. These enhancements and the\ncomponents of are step-by-step detailed in the followings.", 
            "title": "The Tomochain architecture"
        }, 
        {
            "location": "/whitepaper/#Sec:StakeVoting", 
            "text": "", 
            "title": "Stakeholders &amp; Voting"
        }, 
        {
            "location": "/whitepaper/#coin-holders-masternodes", 
            "text": "Coin-holder is as simple as its name: users who join the network, who\nown and transfer $TOMO. Masternodes are full-nodes which maintain a\ncopy of the blockchain, produce blocks and keep the chain consistent. It\nis worth noting that, does not have miners as in the current\nProof-of-Work-based blockchain systems such as Bitcoin and Ethereum.\nOnly masternodes can produce and validate blocks.  Masternodes are selected via a voting system. The first requirement of\nbeing masternodes is to deposit 50 000 $TOMO to the Voting Smart\nContract. Then, these depositors are listed as masternode candidates in\nthe Voting DApp, which allows coin-holders to vote for them by sending\n$TOMO to the smart contract.  Masternodes which work hard in the system to create and verify blocks\nwill be incentivized with $TOMO. Furthermore, coin holders who vote for\nthese incentivized masternodes will also receive $TOMO in proportion to\nthe amount of $TOMO they have invested via ballots. engineers take\nresponsibility to design that fair, explicit, automated and accountable\nreward mechanism.  The list of masternode candidates is dynamically sorted based on voted\ncoins. The performance of the masternodes will be tracked and reported\nback to the coin holders in terms of three main metrics: CPU/Memory\ncharts which ensure the workload of the masternodes, the number of\nsigned blocks which indicates their work performance and the last signed\nblock which figures out their last activity. Coin-holders, at any time,\ncan unvote masternodes, who have low performance, and give their votes\nto the other masternodes who have beter performance. Coin-holders have\nincentives to do that because their voted coins are seen as investment\nto their supported masternodes, thus they should choose a voting\nstrategy in order to maximize their profit from the investment.  This simple trick keeps the system healthy since masternodes always have\nto race for their position so that all weak masternodes will eventually\nbe eliminated. Therefore, only the strongest masternodes are voted and\ncan flourish.", 
            "title": "Coin Holders, Masternodes"
        }, 
        {
            "location": "/whitepaper/#voting-masternode-committee", 
            "text": "There are maximum ninety-nine masternodes elected in the masternode\ncommittee. The required amount of deposit for masternode role is set at\n50 000 $TOMO. This amount is locked in a  voting smart contract . Once\na masternode is demoted (by not remaining in the top ninety-nine voted\nmasternodes) or intentionally quits the masternode candidates\nlist/masternode committee, the deposit will have been locked for a\nmonth.  Coin-holders can vote at any time, by any number of votes (which is\nactually counted by the amount of $TOMO they bet on some masternode\ncandidates). They can use masternode\u2019s performance statistics in the\ngovernance  Voting DApp  as reference information to give votes. The set\nof masternodes is dynamically sorted by the amount of $TOMO and counted\nup to ninety-nine, upon reception of votes.", 
            "title": "Voting &amp; Masternode Committee"
        }, 
        {
            "location": "/whitepaper/#reward-mechanism", 
            "text": "For each iteration of 990 blocks (called epoch), a checkpoint block is\ncreated, which implements only reward works. The masternode, who takes\nturn in the circular and sequential order to create block, has to scan\nall of the created blocks in the epoch and count number of signatures.\nThe reward mechanism is designed following the policy as follow: the\nhigher number of signatures one masternode has made, the more reward he\nearns. For instance, within an epoch, masternode A who has sealed twice\nthe blocks than masternode B earns double amount of $TOMO than\nmasternode B does.  Furthermore, there is also a reward sharing ratio among coin-holders and\nmasternode who has been elected supported by the coin-holders. For\nexample, within an epoch, one masternode receives  X  $TOMO. Ten\npercent of  X  is sent to the masternode\u2019s address. Eighty percent of X  is shared in proportion to the amount of coins deposited and voted\nby the masternode and coin-holders, respectively. The last ten percent\nof  X  credits to the foundation. Coin-holders who unvote before the\ncheckpoint block will not receive any shared reward.", 
            "title": "Reward Mechanism"
        }, 
        {
            "location": "/whitepaper/#Sec:ProtocolOverview", 
            "text": "", 
            "title": "Tomochain Consensus Protocol"
        }, 
        {
            "location": "/whitepaper/#double-validation-process", 
            "text": "In , masternodes share equal responsibility to run the system and keep\nit stable. Full nodes should run on powerful hardware configuration and\nhigh-speed network connectivity in order to ensure the required block\ntime (target to two seconds). Only masternodes can produce and seal\nblocks. In order for that, the consensus relies on the concept of Double Validation  that improves some existing consensus mechanisms,\nnamely  Single Validation . In the followings, we first describe the Double Validation , then analyze the differences and improvements of Double Validation  compared to  Single Validation .", 
            "title": "Double Validation Process"
        }, 
        {
            "location": "/whitepaper/#double-validation-dv", 
            "text": "Similar to some existing PoS-based blockchains such as Cardano, each\nblock is created by a block producer, namely masternode, that takes its\nblock creation permission turn following a pre-determined and circular\nsequence of masternodes for each epoch. However, differently from these\nexisting blockchains, DV in requires the signatures of two masternodes\non a block to be able to push the block to the blockchain. One of the\nmasternodes is the  block creator  while the other one, namely  block\nverifier  is randomly selected among the set of voted masternodes that\nvalidates the block and signs it. In the followings, for more\nconvenience,  block creator  and  block verifier  are used\ninterchangeably for the masternode 1 (block producer) and the randomly\nselected masternode 2 for a block, respectively. The process of randomly\nselecting the block verifiers is detailed in the next paragraphs. Note\nthat, there is no mining in the block creation as in Proof-of-Work-based\nblockchains (e.g. Ethereum and Bitcoin). It means that a created block\nis valid if and only if it is sealed by enough two signatures from a\nblock creator and a corresponding block verifier to confirm the\ncorrectness of it.  We believe this DV technique enhances the stability of the blockchain by\ndiminishing the probability of producing \u201cgarbage\u201d blocks while still\nmaintaining the system security and consistency. Randomization of block\nverifiers in DV is the key factor of reducing risks coming from paired\nmasternodes trying to commit malicious blocks. Furthermore, comparing to\nsome current public blockchains in the market, by utilizing the DV\ntechnique, brings significant improvements in the block time by only\nrequiring two signatures per block. For the purpose of showing our\nenhancement over existing PoS-based blockchains, we analyze the\ndifferences between DV and the Single Validation mechanism in some\nexisting blockchains as follows.", 
            "title": "Double Validation (DV)"
        }, 
        {
            "location": "/whitepaper/#improvements-of-double-validation-over-single-validation", 
            "text": "Let\u2019s show the improvements of DV compared to Single Validation through\nanalyzing some attacking scenarios as shown in Fig. fig:singlevalidation  and Fig.  fig:doublevalidation .   Single Validation  In Single Validation, in an epoch, each\n    masternode, e.g. M1, sequentially takes its turn to create a\n    block, e.g. block100. The next masternode, e.g. M2, in the sequence\n    then validates the created block100. If block100 is invalid (that\n    potentially means that M1 is an attacker) and contains a transaction\n    that invalidly benefits M1, if M2 is honest (see Fig.\n     fig:singlevalidation  a ), it rejects block100 and creates\n    another block100 next to block99. But, if M2 is an attacker\n    (see Fig.  fig:singlevalidation  b ) that corporates with M1,\n    M2 ignores the invalidation of block100, signs it and creates next\n    block, namely block101 that is valid. Then, the next masternode M3\n    verifies that block101 is valid, M3 signs block101 and creates a\n    block102. By this way, Single Validation potentially leaves the\n    blockchain with \u201cgarbage\u201d or invalid blocks which require a \u201crebase\u201d\n    to restore the validity of the blockchain.     Double Validation  We claim that our DV technique significantly\n    reduces the probability of having garbage blocks in the blockchain.\n    Assuming that M1 and M2 are the block creator and block verifier,\n    respectively, for block100 in our DV. If block100 is invalid and M2\n    is honest (see Fig.  fig:doublevalidation  a ), M2 will not\n    seal this block. Therefore, the next block creator M3 for creating\n    block101 will see that block100 does not have enough 2 signatures,\n    thus reject block100 and create another block100 next to block99. On\n    the other hand, if M2 is also an attacker pairing/handshaking with\n    M1 (see Fig.  fig:doublevalidation  b ), M2 signs block100\n    despite its invalidity (remember that the block verifier M2 is\n    randomly selected, there has little chance of successfully pairing\n    M1 and M2). Next, even though M3 will verify that block100 has two\n    valid signatures, M3 still rejects it because block100 is\n    invalidated by M3 that will create another valid block100. In order\n    to break the stability and consistency of the blockchain in this\n    case, M3 should be an attacker together with M1 and M2, which,\n    however, has a very low probability. In other words, DV strengthens\n    the consistency of the blockchain and makes it hard to break.", 
            "title": "Improvements of Double Validation over Single Validation"
        }, 
        {
            "location": "/whitepaper/#randomization-for-block-verifiers-for-double-validation", 
            "text": "", 
            "title": "Randomization for Block Verifiers for Double Validation"
        }, 
        {
            "location": "/whitepaper/#the-first-masternodeblock-creator", 
            "text": "The first masternode/block creator in a given epoch  e  can be selected\nby a round-turn game and can be formal defined as an array:   \\begin{bmatrix} \n\\nu_1\n\\end{bmatrix}\n= \\begin{bmatrix} \nV_{1.1}^e  \\\\\nV_{1.2}^e\\\\\n\\cdot\\\\\n\\cdot\\\\\n\\cdot\\\\\nV_{1.n-1}^e\\\\\nV_{1.n}^e\\\\\n\\end{bmatrix}", 
            "title": "The First Masternode/Block Creator"
        }, 
        {
            "location": "/whitepaper/#random-matrix-and-smart-contract", 
            "text": "Let  m  be the number of masternodes,  n  be the number of slots in an\nepoch. In order to randomly generate the block verifiers for the next\nepoch  e+1 , the process is performed by the following steps.    Step 1: Random Numbers Generation and Commitment Phase:  First, at the beginning of epoch  e , each masternode  V_i  will\nsecurely create an array of  n+1  special random numbers  Recommend_i= [ r_{i.1}, r_{i.2}, ..., r_{i.n}, \\theta_i] , where r_{i.k}\\in [1, ..., m]  indicating the recommendation of ordered\nlist of block verifiers for the next epoch of  V_i , and \\theta_i \\in \\{-1, 0, 1\\}  is used for increasing the\nunpredictability of the random numbers. Second, each masternode V_i  has to encrypt the array  Recommend_i  using a secret key, say Secret_i = Encrypt (Recommend_i) . Next, each masternode forms a\n\" lock \u201d message that contains encrypted shares  Secret_i ; signs\nthis message with its blockchain\u2019s private key, specifies the\nepoch\u2019s number and attaches its public key. In this case, every\nmasternode can check who created this  lock  message and which epoch\nit relates to. Then, each node  V_i  sends this  lock  message to a Smart contract  stored in a block of the blockchain, so\neventually each masternode collects and knows the  lock s from all\nother masternodes.    Step 2: Discovery and Recovery Phase:  The discovery phase is\n    where a masternode sends an \u201d unlock \u201d message, or special value for\n    other masternodes to open its  lock . A  lock  is like a black box\n    (with a secret value  Secret_i  encrypted of  Recommend_i  in it),\n    and the act of opening involves a key that reveals the box to\n    retrieve the value of  Recommend_i . Eventually, a masternode has\n    both  lock s and  unlock s of others. If some elector is an\n    adversary and can publish its  lock  but not publish its  unlock ,\n    in this case, other masternodes can ignore the adversary\u2019s  lock \n    and set all its random values be  1  as default. The idea is simple:\n    a masternode can keep working successfully even if some masternodes\n    are adversaries.    Step 3: Assembled Matrix and Computation Phase:  At the point of\n    the slot  n^{th}  of the epoch  e , the secret arrays  Secret_I  in\n    the smart contract will be decrypted by each masternode and return\n    the plain version of  Recommend_i . Each tuple of the first  n \n    numbers of each  V_i  will be assembled as the  i^{th}  column of an\n     n \\times m  matrix. All the last number  \\theta_i  forms a\n     m\\times 1  matrix. Then each nodes will compute the block verifiers\n    ordered list by some mathematical operations as explained below. The\n    resulting output is a matrix  n \\times 1  indicating the order of\n    block verifiers for the next epoch  e+1 .", 
            "title": "Random Matrix and Smart Contract"
        }, 
        {
            "location": "/whitepaper/#the-second-masternodeblock-verifier", 
            "text": "Then, each node soon compute the common array  \\nu_2  for the order of\nthe block verifiers by the following steps as in Equation  eq:matrix .   \\label{eq:matrix}\n\\begin{bmatrix} \\nu'_2\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nv_{2.1}^{e+1} \\\\\nv_{2.2}^{e+1} \\\\\n\\vdots \\\\\nv_{2.n}^{e+1}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nr_{1.1}  & r_{2.1}            & \\cdots  & r_{m.1}  \\\\\nr_{1.2}     & r_{2.2}       & \\ddots  & \\vdots   \\\\\nr_{1.3}      &  \\ddots   & \\ddots  & r_{m.3}  \\\\\n\\vdots  &              & r_{m-1.n-1}  & r_{m.n-1}  \\\\\nr_{1.n}      & \\cdots      & r_{m-1.n}      & r_{m.n}\n\\end{bmatrix}   \n\\begin{bmatrix}\n\\theta_1  \\\\\n\\theta_2  \\\\\n\\theta_3 \\\\\n\\vdots  \\\\\n\\theta_m\n\\end{bmatrix}    \\label{eq:eq2}\n\\begin{bmatrix} \\nu_2\n\\end{bmatrix}\n=\n\\begin{bmatrix} \\nu'_2 & mod & m\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\left| v_{2.1}^{e+1}\\right| & mod & m \\\\\n\\left| v_{2.2}^{e+1} \\right| & mod &  m\\\\\n\\vdots \\\\\n\\left| v_{2.n}^{e+1} \\right| & mod & m\n\\end{bmatrix}   Then,  \\nu_2  is obtained by modulo operation of element values of \\nu'_2  as in Equation  eq:eq2 :", 
            "title": "The Second Masternode/Block Verifier"
        }, 
        {
            "location": "/whitepaper/#finality-analysis", 
            "text": "There is a standard definition of \u201ctotal economic finality\u201d: it takes\nplace when  \\frac{3}{4}  of all masternodes make maximum-odds bets that\na given block or state will be finalized. This condition offers very\nstrong incentives for masternodes to never try colluding revert the\nblock: once masternodes make such maximum-odds bets, in any blockchain\nwhere that block or state is not present, the masternodes lose their\nentire deposit.  keeps that standardization in the design so that one block is considered\nas irreversible if it collects up to  \\frac{3}{4}  signatures of all\nmasternodes committee. The time-line of blockchain creation process,\nchecking finality and mark the block as immutable is described as in\nFigure:  ChainMaking  below.", 
            "title": "Finality Analysis"
        }, 
        {
            "location": "/whitepaper/#Sec:ProtocolFormalization", 
            "text": "", 
            "title": "Consensus Protocol: Formalization"
        }, 
        {
            "location": "/whitepaper/#basic-concepts-protocol-description", 
            "text": "We begin by describing the blockchain protocol in the \"stakeholder and\nvoting\u201d setting, where leaders are assigned to blockchain slots with\nprobability proportional to their (fixed) initial stake and votes\nreceived from coin-holders which will be the effective stake\ndistribution throughout the execution. To simplify our presentation, we\nabstract this leader (chairman and vice-chairman) selection process,\ntreating it simply as an \u201cideal functionality\u201d that faithfully carries\nout the process of randomly assigning masternodes to slots. In the\nfollowing, we explain how to instantiate this functionality with a\nspecific secure computation.  To start, as we are dealing with proof of stake consensus algorithm, we\nfollow the way of formalization in the recent works in the literature\nlike \u00a0@Cardano2017 and \u00a0@Pass2017 [@PassCrypto2017]. In particular, we\nrecall the following concepts and definitions that were presented\nin\u00a0@Cardano2017:", 
            "title": "Basic Concepts &amp; Protocol Description"
        }, 
        {
            "location": "/whitepaper/#time-slots-epoch", 
            "text": "We consider a setting where time is divided into discrete units called slots . A ledger, described in more detail below, associates with each\ntime slot (at most) one ledger  block . Players are equipped with\n(roughly synchronized) clocks that indicate the current slot. This will\npermit them to carry out a distributed protocol intending to\ncollectively assign a block to this current slot. In general, each slot sl_r  is indexed by an integer  r \\in \\{1, 2, . . .\\} , and we assume\nthat the real time window that corresponds to each slot has the\nfollowing properties.    The current slot is determined by a publicly-known and monotonically\n    increasing function of current time.    Each player has access to the current time. Any discrepancies\n    between parties\u2019 local time are insignificant in comparison with the\n    length of time represented by a slot.    The length of the time window that corresponds to a slot is\n    sufficient to guarantee that any message transmitted by an honest\n    party at the beginning of the time window will be received by any\n    other honest party by the end of that time window (even accounting\n    for small inconsistencies in parties\u2019 local clocks). In particular,\n    while network delays may occur, they never exceed the slot\n    time window.    In each slot  sl_r , and for each active masternode  V_j  there will be\na set  S_j(r)  of public-keys and stake pairs of the form (vk_i,s_i) \\in {0,1}^* \\times N , for  i = 1,...,n_r  where  n_r  is\nthe number of users introduced up to that slot that will represent who\nare the active participants in the view of  V_j . Public-keys will be\nmarked as \u201cidle\u201d if the corresponding stakeholder has been corrupted.  As mentioned in Section\u00a0 Sec:TomochainOverview , in our setting, we\nassume that the fixed collection of  m  masternodes V_1, V_2, ...., V_m  interact throughout the protocol. Masternode  V_i \npossesses  s_i  stake (coin) before the protocol starts. For each  V_i \na verification and signing key pair  (vk_i,sk_i)  for a prescribed\nsignature scheme is generated; we assume without loss of generality that\nthe verification keys  vk_1, . . .  are known by all stakeholders.\nBefore describing the protocol, we establish basic definitions following\nthe notation of\u00a0@Garay2015.   Genesis Block  The genesis block  B_0  contains the list of\nstakeholders identified by their public-keys, their respective stakes (vk_1, s_1), . . . , (vk_n, s_n)  and auxiliary information  \\rho ,\nwhere the auxiliary information  \\rho  will be used to seed the slot\nleader election process.   State  A state is an encoded string  st \\in \\{0,1\\}^\\lambda .   Block  A block  B  generated at a slot   sl_i \\in \\{sl_1,...,sl_R\\} \ncontains the current state  st \\in \\{0, 1\\}^{\\lambda} , data d \\in \\{0, 1\\}^{*} , the slot number  sl_i  and a signature \\Sigma  =  Sign_{ski} (st, d, sl_i)  computed under  sk_i \ncorresponding to the masternode  V_i  generating the block.   Blockchain  A blockchain  C  (or simply chain) relative to the\ngenesis block  B_0  is a sequence of blocks  B_1,..., B_n  associated\nwith a strictly increasing sequence of slots for which the state  st_i \nof  B_i  is equal to   H (B_{i-1}) , where  H  is a prescribed\ncollision-resistant hash function. The length of a chain  len(C) = n  is\nits number of blocks. The block  B_n  is the head of the chain, denoted head(C) . We treat the empty string  \\epsilon  as a legal chain and by\nconvention set  head(\\epsilon) = \\epsilon .   Epoch  An epoch is a set of  R  adjacent slots S = \\{sl_1, . . . , sl_R\\} . The value  R  is also a parameter (slots\nnumber in each epoch) of the protocol we analyze in our model.  As mentioned earlier, in our model, we set each time  slot   sl_i  as 2\nseconds; an epoch is a set  R  of 990 slots \\{ sl_1, sl_2, ..., sl_{990}\\}  (an epoch time duration equals to 1980\nseconds).  In summary, the consensus protocol of can be formalized in\nAlgorithm\u00a0 Al:ValidatorGeneration . The\nAlgorithm\u00a0 Al:ValidatorGeneration  is simulated and explained as a\nprocess shown in Fig.  EpochProcess .", 
            "title": "Time, Slots, Epoch"
        }, 
        {
            "location": "/whitepaper/#Sec:SecurityAnalysis", 
            "text": "", 
            "title": "Security Analysis"
        }, 
        {
            "location": "/whitepaper/#nothing-at-stake", 
            "text": "Nothing-at-stake is a well-known problem in PoS-based blockchain, just\nlike 51% attack in PoW algorithm. PoW-based miners require CapEx\n(capital expenditures) for buying mining equipment such as ASICs and\nOpEx (operation expenditures) such as electricity to solve mathematical\npuzzles securing the network @capex. That means, there is always an\nintrinsic cost for miners in mining regardless of its success. In case\nof a fork, miners therefore always allocate their resource (equipment)\nto the chain that they believe is correct in order to get incentives for\ncompensating the intrinsic costs in mining.  In the contrary, in PoS-based systems without mining, during an ideal\nexecution, for creating a fork only costs, masternodes actually do not\nincur intrinsic costs, other than roughly some block validation and\nsigning cost. As a result, there\u2019s an inherent problem of the masternode\nhaving no downside to staking both forks. Therefore, there are actually\ntwo issues in the original design of PoS. On one hand, for any\nmasternode, the optimal strategy is to validate every chain/fork, so\nthat the masternode gets their rewards no matter which fork wins. On the\nother hand, for attackers/malicious masternodes, they can easily create\na fork for double spending.  Let\u2019s look back how handles these two problems. As a reminder, maintains\na certain order of masternodes in creating and sealing blocks, in each\nepoch. For the first issue, random/arbitrary forks are hardly happened\nbecause the order of block creation masternodes is pre-determined for\neach epoch. Furthermore, the Double Validation mechanism eliminates the\nsecond issue because even one malicious masternode creates two blocks at\nhis turn, only one block then can be validated by the second randomly\nselected masternode.", 
            "title": "Nothing-at-stake"
        }, 
        {
            "location": "/whitepaper/#long-range-attack", 
            "text": "In , block is valid only if it collects double validation and finalized\nonce  \\frac{3}{4}  of masternodes verify. Therefore, as long as the\nnumber of attackers or malicious nodes and/or fail-stop nodes is less\nequal than  \\frac{1}{4}  the number of masternodes, the number of\nmasternodes signing a block is at least  \\frac{3}{4}  the total number\nof masternodes, which makes the block finalized. Thus, there is no\nchance for one malicious masternode to create longer valid chain because\nother masternodes will refuse it.", 
            "title": "Long-range attack"
        }, 
        {
            "location": "/whitepaper/#censorship-attack", 
            "text": "If there are more than  \\frac{3}{4}  malicious masternodes in ,\ncensorship attack might happen. For example, these masternodes refuse\nvalid blocks or simply become inactive. In this case, chain is stuck.  In fact, masternodes are paid for their effort of correctly working so\nthat the chain is actively updated in a consistent manner. More\nimportantly, becoming masternode means a certain amount of coins is\nlocked, 50 000 $TOMO in particular. As a result, in order to control\nmore than \\frac{3}{4}  masternodes, attackers must hold a considerable\namount of $TOMO and gain huge support from coin-holders. And because of\nthis, the attackers do not have incentives to do any malicious action to\nharm the chain.  However, in worst case, has to do a soft fork in order to reduce number\nof masternodes to keep the chain running and figure out slasher\nmechanisms for those malicious masternodes.", 
            "title": "Censorship Attack"
        }, 
        {
            "location": "/whitepaper/#relay-attack", 
            "text": "supports EIP155\\ (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md) .\nTransactions in are included  CHAIN\\_ID  specified for different public\nchains. Table  table:chainid  shows recognized  CHAIN\\_ID s.     CHAIN_ID  Chain(s)      1  Ethereum mainnet    2  Morden (disused), Expanse mainnet    3  Ropsten    4  Rinkeby    30  Rootstock mainnet    31  Rockstock testnet    42  Kovan    61  Ethereum Classic mainnet    62  Ethereum Classic testnet    1337  Geth private chains (default)    77  Sokol, the public POA Network testnet    99  Core, the public POA Network main network    88  Mainnet    89  Testnet      Chains and chain_id", 
            "title": "Relay Attack"
        }, 
        {
            "location": "/whitepaper/#safety-and-liveness", 
            "text": "Safety implies having a single agreed upon chain where there are not two\nor more competing chains with valid transactions in either @Safety. A\nconsensus protocol can be  safe  when blocks have settlement finality,\nor else probabilistic finality. This last sentence reveals that can\nprovide safety because it has a settlement finality.  A consensus protocol is considered  live  if it can eventually propagate\nand make valid transactions onto the blockchain @Safety. An occurrence\nof a liveness fault is when transaction omission, information\nwithholding, or message reordering, among a number of violations are\nobserved. This type of fault is unlikely to happen in because the block\ncreation masternodes list is ordered in a pre-determined way for each\nepoch, thus if even an attacking masternode omits some transactions, the\nlatter will be processed and validated by the next honest masternode in\nthe next block.", 
            "title": "Safety and liveness"
        }, 
        {
            "location": "/whitepaper/#ddos-attack", 
            "text": "Masternodes are encouraged to run in well-known public cloud providers\nsuch as AWS, Google Cloud or Microsoft Azure which provides multiple\nDDOS prevention mechanisms. Even in case that some nodes are attacked or\nfail-stop, the network still works correctly as long as the number of\nfailing and/or attacked nodes is less than 1/4 of the number of\nmasternodes.", 
            "title": "DDOS Attack"
        }, 
        {
            "location": "/whitepaper/#spam-attack", 
            "text": "keeps the same transaction fee mechanism as Ethereum which is indicated\nvia gasPrice. However, supports minimum transaction fee (at 1 wei),\nwhich somehow enables spamming that attacker tries to broadcast a huge\namount of low fee transactions to the system. However, masternodes\nalways sort transactions and pick up only high fee transactions into the\nproposing block. Thus, spammers have little chance to harm the system.", 
            "title": "Spam Attack"
        }, 
        {
            "location": "/whitepaper/#Sec:relatedwork", 
            "text": "Consensus plays an important role to guarantee the success of\ndistributed and decentralized systems. Bitcoin\u2019s core consensus\nprotocol, often referred to as Nakamoto consensus\u00a0@Bitcoin08, realizes a\n\u201creplicated state machine\u201d abstraction, where nodes in a permissionless\nnetwork reach agreement about a set of transactions committed as well as\ntheir ordering \u00a0@hybrid. However, known permissionless consensus\nprotocols such as Bitcoin\u2019s Nakamoto consensus come at a cost. Bitcoin\nand Ethereum rely on PoW to roughly enforce the idea of \u201cone vote per\nhashpower\u201d and to defend against Sybil attacks. Unfortunately, PoW-based\nBitcoin and Ethereum are known to have terrible performance (Bitcoin\u2019s\ntransaction processing performance is at peak of around 7 transactions\nper second as previously mentioned). Moreover, PoW is much criticized\nbecause it costs a lot of electricity energy.  In order to design an efficient and cost-effective consensus protocol in\nthe permissionless model, PoS has been discussed extensively in the\nBitcoin and Ethereum forum\u00a0@Ethe2014 [@Larime2016]. A PoS blockchain can\nsubstitute the costly PoW in Nakamoto\u2019s blockchain while still providing\nsimilar guarantees in terms of transaction processing in the presence of\na dishonest minority of users, where this \u201cminority\u201d is to be understood\nhere in the context of stake rather than computational\npower\u00a0@Cardano2017. The Ethereum design Casper\u00a0@Casper, published by\nButerin   Griffith, provides as its initial version a PoW/PoS hybrid\nconsensus protocol, which might eventually switch to a pure PoS system.\nAs in , Ethereum Casper requires that  validators  (term similar to\nblock creators) have to deposit an amount. In fact, some concepts used\nin such as checkpoint blocks are borrowed from Casper. Our (PoSV)\nconsensus protocol proposed in this paper can be seen as a hybrid model.\nIn particular, first, we apply with voting and  Double Validation  to\ncreate, verify and vote for blocks smoothly and efficiently. Whenever\npotentials of fork branches are detected, we employ the idea in PoW to\nselect the longest branch with the most votes and discard the other\nbranches. With this hybrid approach, does not only increase the\nperformance and security of blockchain, but also reduce the fork\nsituation in an efficient and practical manner.  Recently, there are several consensus protocol research works that are\nclosely related to such as EOS\u00a0@EOS and Ouroboros of\nCardano\u00a0@Cardano2017. The mechanism of  voting  for masternodes for\nreaching consensus is utilized by Bitshares @bitshare and EOS @EOS,\nwhose consensus protocol is termed  Delegated Proof-of-Stake  (DPoS).\nDPoS is similar to the Proof-of-Stake Voting consensus of in the sense\nthat masternodes (block creators or  witnesses  in DPoS) are elected\nthrough a voting system. However, requires that masternodes need to\ndeposit a required minimum amount of $TOMO to become a masternode\ncandidate, which puts more pressure on the masternodes to work honestly.\nFurthermore, the  Double Validation  mechanism of lowers the\nprobability of handshaking attacks and having invalid blocks, as\npreviously analyzed. EOS also has a maximum of 21 block producers for\neach epoch, which is  less decentralized  than with a maximum of 99\nmasternodes elected.  The research-backed Cardano\u00a0@Cardano2017 blockchain solution, namely\nOuroboros, with the ADA coin, which is purely based on Proof-of-Stake,\npromisingly claims to provide rigorous security guarantees. Similarly to\n, Ouroboros has a set of block producers for each epoch for creating\nblocks and each block producer candidate needs to deposit a minimum\namount of stake (an amount of ADA). However, note that, Ouroboros only\nprovides  Single Validation , while  Double Validation  of provides\nseveral advantages over Single Validation, as previously analyzed. In\nOuroboros, the order of block producers, selected among stakers, is\nbased on a biased randomization while the \u2019s randomization for block\nverifiers is potentially uniform and based on smart contracts.\nFurthermore, the use of voting as in and DPoS enables a more incentive\nequality between stakers: In Ouroboros, stakers with very little stake\nhave a very small probability of becoming block creators, while, in ,\nthese stakers can choose an optimal strategy to vote for potential\nmasternodes to get incentives.", 
            "title": "Related work"
        }, 
        {
            "location": "/whitepaper/#Sec:Conclusion", 
            "text": "In this paper, we proposed PoSV, a PoS Voting-based blockchain protocol\nwith heuristic and fair voting mechanism, rigorous security guarantees,\nand fast finality. We also presented a novel reward mechanism and show\nthat, with this mechanism, the blockchain has a low probability of\nhaving forks, fast confirmation time, plus the contributions and\nbenefits of masternodes are fair in the sense that the probability\ndistribution function is uniform eventually.  0.3cm", 
            "title": "Conclusion and perspectives"
        }, 
        {
            "location": "/whitepaper/#perspectives", 
            "text": "Future work  The team is currently working on the implementation\n    of the Proof-of-Stake Voting, which will be released on schedule as\n    stated in our roadmap. Furthermore, in parallel with our novel\n    consensus protocol, we will investigate the Sharding mechanism in\n    order to provide even better transaction processing performance. We\n    believe that, the Sharding technique with the stable number of\n    masternodes will provide better stability and efficiency to\n    the blockchain. At the same time, we commit to keep EVM-compatible\n    smart contracts within our masternode sharding framework.    Economic sustainability  is also an important concept for a\n    blockchain based decentralized network. That means to maintain the\n    network in a sustainable condition, an equilibrium needs to be\n    achieved, in which the cost of running the network infrastructure\n    could be offset by the revenues generated. In this context, the cost\n    of network infrastructure consists of two parts: the physical cost\n    of having hardware such as servers, memories that passes the network\n    technical requirements; and the capital cost of having $TOMO locked\n    into smart-contracts. The revenues for Masternodes would primarily\n    come from Reward Engine emission, and later on from service revenues\n    such as token exchange fees provided by applications running on top\n    of TomoChain. We will publish a TomoChain economic analysis and\n    proposal, separate from this technical paper in a later date.", 
            "title": "Perspectives"
        }, 
        {
            "location": "/whitepaper/#references", 
            "text": "Satoshi Nakamoto. Bitcoin: A peer-to-peer electronics cash system. 2008.  Ethereum Foundation. Ethereum\u2019s White Paper. , 2014. Online available 25/05/2018.  D. Larimer. Delegated Proof-of-Stake (DPOS). BitShare White Paper 2014.  S. King and S. Nadal. PPCoin: Peer-to-peer crypto-currency with\nproof-of-stake. Self-Published, 2012.  V. Buterin. On public and private blockchains. Ethereum Blog, 2015.  A. Kiayias, A. Russell, B. David, and R. Oliynykov: Ouroboros: A\nProvably Secure Proof-of-Stake Blockchain Protocol. IACR-CRYPTO-2017.  D. Mingxiao, et al. A Review on Consensus Algorithms of Blockchain. 2017\nIEEE International Conference on Systems, Man, and Cybernetics (SMC)\nBanff Center, Banff, Canada, October 5-8, 2017  R. Pass and E. Shi. Rethinking Large-Scale Consensus. In the Proceedings\nof the IEEE 30th Computer Security Foundations Symposium, 2017. Thunder\nToken Foundation: Thunder Consensus White Paper, Janurary, 2018.  R. Pass, L. Seeman, and A. Shelat. Analysis of the Blockchain Protocol\nin Asynchronous Networks. In EUROCRYPTO 2017.  Juan A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone\nprotocol: Analysis and applications. In Elisabeth Oswald and Marc\nFischlin, editors, Advances in Cryptology - EUROCRYPT 2015, Volume 9057\nof Lecture Notes in Computer Science, pages 281\u2013310. Springer, 2015.  Tendermint Team. Understanding the Basics of a Proof-of-Stake Security\nModel.\nhttps://blog.cosmos.network/understanding-the-basics-of-a-proof-of-stake-security-model-de3b3e160710.\nOnline available 25/05/2018.  EOS Team. EOS.IO Technical White Paper v2. https://github.com/EOSIO/Documentation/blob/master/TechnicalWhitePaper.md .\nOnline available 25/05/2018.  Bitshares Team. Delegated Proof-of-Stake Consensus.\nhttps://bitshares.org/technology/delegated-proof-of-stake-consensus/.\nOnline available 25/05/2018.  R. Pass, and E. Shi. (2017). Hybrid consensus: Efficient consensus in\nthe permissionless model. In LIPIcs-Leibniz International Proceedings in\nInformatics (Vol. 91). Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik.  V. Buterin, and V. Griffith. (2017). Casper the Friendly Finality\nGadget. arXiv preprint arXiv:1710.09437.  H. McCook. Under the Microscope: Economic and Environmental Costs of\nBitcoin Mining. https://www.coindesk.com/microscope-economic-environmental-costs-bitcoin-mining/ .\nOnline available 25/05/2018.", 
            "title": "References"
        }, 
        {
            "location": "/links/", 
            "text": "Links\n\n\n\n\n\n\nMain website - \nhttps://tomochain.com\n\n\n\n\n\n\nTestwallet - \nhttps://wallet.tomocoin.io\n\n\n\n\n\n\nWhitepaper - \nhttps://tomochain.com/docs/technical-whitepaper--1.0.pdf\n\n\n\n\n\n\nNetwork stats - \nhttps://stats.tomocoin.io\n\n\n\n\n\n\nExplorer - \nhttps://explorer-testnet.tomochain.com\n\n\n\n\n\n\nGovernance dapp - \nhttps://validators-testnet.tomochain.com\n\n\n\n\n\n\nDapp tutorial - \nhttps://github.com/nuuneoi/tomochain-dapp-example\n\n\n\n\n\n\nGithub - \nhttps://github.com/tomochain", 
            "title": "Important Links"
        }, 
        {
            "location": "/links/#links", 
            "text": "Main website -  https://tomochain.com    Testwallet -  https://wallet.tomocoin.io    Whitepaper -  https://tomochain.com/docs/technical-whitepaper--1.0.pdf    Network stats -  https://stats.tomocoin.io    Explorer -  https://explorer-testnet.tomochain.com    Governance dapp -  https://validators-testnet.tomochain.com    Dapp tutorial -  https://github.com/nuuneoi/tomochain-dapp-example    Github -  https://github.com/tomochain", 
            "title": "Links"
        }, 
        {
            "location": "/about/", 
            "text": "About\n\n\nCompany\n\n\nCompany information\n\n\nTomoChain Pte. Ltd.\nSingapore Headquarters \n10 Anson Road #22-15 \nInternational Plaza \nSingapore 079903\n\n\nLicense\n\n\nLicense information", 
            "title": "About"
        }, 
        {
            "location": "/about/#about", 
            "text": "", 
            "title": "About"
        }, 
        {
            "location": "/about/#company", 
            "text": "Company information  TomoChain Pte. Ltd.\nSingapore Headquarters \n10 Anson Road #22-15 \nInternational Plaza \nSingapore 079903", 
            "title": "Company"
        }, 
        {
            "location": "/about/#license", 
            "text": "License information", 
            "title": "License"
        }
    ]
}